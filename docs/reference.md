# API reference

## Table of Contents

- [Project Structure](#project-structure)
- [JS Partials](#js-partials)
- [JS Modules](#js-modules)
- [Islands](#islands)
- [Getters](#getters)
- [Hooks](#hooks)
- [Components](#components)
- [cms-dev-server](#hubspotcms-dev-server)
- [Styling](#styling)
- [Static assets](#static-assets)
- [Third-party dependencies](#third-party-dependencies)
- [Prerendering](#prerendering)
- [Testing](#testing)

## Project Structure

This is the top-level structure to be used for JS rendering projects:

```
project-folder/
│
├── js-package/
│   ├── components/
│   │   ├── partials/
│   │   └── modules/
│   ├── cms-assets.json
│   └── package.json
│
├── … optionally other project components …
│
└── hsproject.json
```

A `hsproject.json` file must be inside the root of your project folder in order for `hs project upload` to recognize your project. A `cms-assets.json` file must be inside of your JavaScript asset package subfolder so that the project build can recognize and correctly build your JS components.

This JS building blocks beta introduces the “CMS assets” project component alongside private apps, CRM extensions, and serverless functions. To learn more about HubSpot projects, you can check out the [projects beta documentation](https://developers.hubspot.com/docs/platform/build-and-deploy-using-hubspot-projects).

## JS Partials

Similar to [global partials](https://developers.hubspot.com/docs/cms/building-blocks/global-content?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#global-partials-vs-global-modules), JavaScript partials are “slices” of your page that can be replaced with React. These can be used globally within HubL. Partials must be located in the `components/partials/` subdirectory of the JavaScript project component. For instance, if you have a file `components/partials/Header.jsx`, which default exports a React component, then you can include it in your project HubL like so:

```
{% js_partial
   path="@projects/project-folder/js-package/components/partials/Header.jsx"
   pageTitle="My page"
%}
```

Any parameters passed to `js_partial` alongside the `path` will be available within the React component as props.

## JS Modules

A JS module is just like a [traditional HubL module](https://developers.hubspot.com/docs/cms/building-blocks/modules?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764), in that they have fields, can be edited in the page editor, and can be dragged into Drag and Drop areas, but its HTML is generated by a React component instead of HubL and its fields are generated by JSX instead of JSON. JS Modules must be located in the `components/modules/` subdirectory of the JavaScript project component. JS modules are referenced in HubL like so:

```
{% module "todos"
   path="@projects/hello-world-project/cms-assets/components/modules/TodoList"
%}
```

### Directory Structure Requirements

A JS Module file can live at either of the following paths, using the directory or file name as the module name:

`/components/modules/ExampleModule/index.js`

```
js-package/
└── components/
    └── modules/
        └── ExampleModule/
            └── index.jsx
```

`/components/modules/ExampleModule.jsx`

```
js-package/
└── components/
    └── modules/
        └── ExampleModule.jsx
```

Regardless of the path you chose, the file (i.e. either `ExampleModule/index.jsx` or `ExampleModule.jsx`) must contain the following named exports:

- `Component`: A React component to be rendered. It may contain islands
- `meta`: A JavaScript object, equivalent to the ￼`meta.json`￼ [in CMS modules](https://developers.hubspot.com/docs/cms/building-blocks/modules/configuration?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#meta-json)
- `fields`: A JSX tree using components from `@hubspot/cms-components/fields` to define [module fields](https://docs.google.com/document/d/1SedUwFswfBIxRPDtjlr1LE7sqRSvIcuS9tQXp0f0lKU/edit#heading=h.m2dvp7qc12un)
Note that you may use re-exports, for example:

```
// Directory Structure
js-package/
└── components/
    └── modules/
        └── ExampleModule/
            ├── ExampleModuleFields.jsx
            ├── ExampleModuleComponent.jsx
            ├── ExampleModuleMeta.js
            └── index.js
```

```javascript
// index.js
/*
 Note: index.js re-exports ExampleModuleFields.jsx,
 ExampleModuleMeta.js, and ExampleModuleComponent.jsx as named
 exports
 */
export { default as Component } from './ExampleModuleComponent.js;
export { fields } from './ExampleModuleFields.js;
export { meta } from './ExampleModuleMeta.js;
```

### Module Fields

Fields are expressed as a JSX tree using field components from `@hubspot/cms-components/fields` . These are the same [module fields](https://developers.hubspot.com/docs/cms/building-blocks/modules?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#fields-json) that a developer has access to today. They also include TypeScript definitions, so developers can benefit from autocomplete and validation when defining fields. [Here](/field-types/modules.md) are the TypeDocs of all the exported Field Types.

### Writing Fields.jsx files

Instead of JSON, JS module fields are written using JSX. We believe the JSX field syntax is easier to read than JSON fields. It also allows you to dynamically generate fields, share field logic between modules, and create custom abstractions around field definitions. For example, here is a `FullNameField` custom field component that abstracts out a group of 2 or 3 text fields:

```javascript
import {
  ModuleField,
  TextField,
  FieldGroup,
  BooleanField
} from '@hubspot/cms-components/fields';

const FullNameField = ({ includeMiddleName = false }) => (
  <FieldGroup
    name="full_name"
    label="Full Name"
>
    <TextField
      name="given_name"
      label="Given Name"
      default="HubSpot"
      required={true}
    />
    {includeMiddleName && (
      <TextField
        name="middle_name"
        label="Middle Name"
        default=""
      />
    )}
    <TextField
      name="family_name"
      label="Family Name"
      default="Developer"
    />
  </FieldGroup>
);


export const fields = (
  <ModuleField>
    <TextField
      name="example_field"
      label="Example Text Field"
      default="Placeholder text" />

    <FieldGroup name="group_of_fields" label="Field Group">
      <BooleanField
        name="child_boolean_field"
        label="Child Boolean Field"
        default={true}
      />
      <TextField
        name="child_text_field"
        label="Child Text Field"
        default="Child Field"
      />
    </FieldGroup>


    {/Using the custom field component alongside other fields*/}
    <FullNameField includeMiddleName={false}>
  </ModuleField>
);
```

In the React component for the module fields defined above, props will have the following shape:

```javascript
{
  example_field: "Placeholder text",
  group_of_fields: {
    child_boolean_field: true,
    child_text_field: "Child Field"
  },
  full_name: {
    given_name: "HubSpot",
    family_name: "Developer",
  }
}
```

Note that the default was used to fill in the value field once it was passed. This is because module values are passed from the server, so if someone changes the value of a field in the page editor, the new value will be passed to your module. But in our current case where no page-level field value is set, the server passes the default value to your props.

### Using Field Values

Field values are passed as props to the Component export of your module. For example, to use the field structure from the previous example inside of your JS module’s component you can:

```javascript
export const Component = ({ fields }) => {
  return (
    <ul>
      <li>{fields.example_field}</li>
      <li>{fields.group_of_fields.child_text_field}</li>
    </ul>
  );
};
```

### GraphQL

Like in HubL modules, you can bind a GraphQL data query to a JS module. Adding a named `query` export to a module will provide the query result to render in the component props. and receive the query result in the component props to render using a named `query` export. You can import and re-export a `.graphql` query file or a JavaScript expression that evaluates to a GraphQL query (e.g. with [`gql-query-builder`](https://www.npmjs.com/package/gql-query-builder)). The result will be available via a `dataQueryResult` prop in the module component.

```javascript
// index.js

import ModuleComponent from './ModuleComponent.js';
import ModuleFields from './ModuleFields.js';
import ModuleMeta from './ModuleMeta.js';
import myQuery from './myQuery.graphql';

// This component will receive the query result via `dataQueryResult`
export const Component = ModuleComponent;

export const meta = ModuleMeta;

export const fields = ModuleFields;

export const query = myQuery;
```

## Islands

To use an interactive React component in your page—any component that responds to user input or has state—you need to wrap it with an `<Island>`.

- Here’s how you do that: When importing the component, add `?island` to the end of the import specifier
- Render the Island component from `@hubspot/cms-components`, and pass `InteractiveComponent` from the result of the `?island` import as the `module` prop
- Any serializable props (no functions) can be passed to `Island` and will be received by the component passed to module (`InteractiveComponent` will receive `someProp` when it renders both on the server and client)

```javascript
import { useState } from 'react';
import { Island } from '@hubspot/cms-components';
import InteractiveComponent from '../InteractiveComponent?island';

export default function MyPartial() {
  let [count, setCount] = useState(0);

  return (
    <div>
      <p>
        This content outside of `InteractiveComponent` is server-rendered only
      </p>

      {/*
        This Island wrapper will auto code-split
        InteractiveComponent for you, render it on the server,
        and set it up to hydrate in the browser.
        */}
      <Island module={InteractiveComponent} defaultCount={42} />
    </div>
  );
}
```

```javascript
import { useState } from 'react';

export default function InteractiveComponent({ defaultCount }) {
  let [count, setCount] = useState(defaultCount);

  /*
   Note, this click handler will only work if
   InteractiveComponent was called from inside an <Island>.
   Otherwise the static server HTML returned will be a button
   that does nothing when you try to click it.
   */
  return <button onClick={() => setCount(count + 1)}>Click me!</button>;
}
```

### Island props

#### `hydrateOn`

When rendering a page with Islands on the server the output includes a script to initialize Islands on the client. The default behavior of the island initialization script is to eagerly hydrate all Islands as soon as possible, i.e., on load, but there are other strategies available when hydrating components.

The available hydration types are:

- `load` (default)
- `idle`
- `visible`

These types can be set as the hydrateOn prop on the Island Component, for example:

```javascript
<Island module={InteractiveComponent} hydrateOn=”visible” />
```

For islands with the `idle` hydration type we use [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), allowing the hydration to be deferred. This is good for lower priority components, allowing client resources to be used first on higher priority.

For Islands with the `visible` hydration type we don’t hydrate until the element is visible on screen by using the [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). This mode is good for components that aren't visible to the user immediately, e.g., if they are further down a long page.

Hydrating means downloading and initializing your Island component code, so using these different hydration types strategically to defer some of that work can help boost initial page load performance!

#### `clientOnly`

`boolean`

This is set to `false` by default, but when set to `true` then the Island won’t be rendered on the server. This can be useful for components that rely on logic/libraries that can only run in the browser.

## Getters

### `getHubID`

`( ) => number`

Returns the the current account ID (“Hub ID” or “portal ID”) for the page being rendered

### `getIsDeployed`

`( ) => boolean`

Returns `true` for components rendered live for a deployed project and `false` when rendering in the dev server.

## Hooks

We provide a number of React hooks to help write components that run on both the server and the browser.

### `useAfterIslandHydration`

`( ) => boolean`

Will return `true` only after hydration is completed. More specifically it will:

- Return `true` during the initial render on the server.
- Return `true` during the first render that happens inside the browser.
- Return `false` during any subsequent renders that happen after the component has been “mounted” in the browser.

This hook is useful because React requires server-rendered HTML to match the initial client render. See the [Server/Client Rendering section](appendix.md#server-sideclient-side-rendering) in the appendix for more information.

### `￼useIsServerRender`

`( ) => boolean`

Returns `true` while the component is being rendered on the server and `false` in the browser. Note, in most cases it is better to use `useAfterIslandHydration()`, since it makes it easier for your code to “do the right thing” for hydration.

### `usePageUrl`

`( ) => URL` Returns the current page [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL). Works on server and is reactive to changes to the URL on client. This can be useful when components need to react to URL changes, such as query params, while also supporting server rendering.

### `useSharedIslandState`

```javascript
const [sharedState, updateSharedState, sharedStateID] = useSharedIslandState();
```

Returns an object of state shared multiple islands and updater function. It works similarly to `useState`, but updating the state via `updateSharedState(newValue)` will "reach across" and update all of the other islands that also use `useSharedIslandState()`. Works in coordination with the `SharedIslandState` component.

### `useSharedIslandReducer`

```javascript
const [sharedState, dispatch] = useSharedIslandReducer();
```

Returns an object of state shared multiple islands and a dispatch function. It works similarly to `useReducer`, but actions dispatched will "reach across" and update all of the other islands that also use `useSharedIslandReducer()`. Works in coordination with the `SharedIslandReducer` component.

## Components

### `<SharedIslandState>`

Defines the initial value for the shared state accessed in `useSharedIslandState()` by other islands in this JS module or partial. All islands that are are "wrapped" by `SharedIslandState` (i.e. are children or descendents of the children) will share a single state reference. Note, `SharedIslandState` must be rendered on the server and cannot be contained inside an island.

```javascript
<SharedIslandState value={...}>
  …
</SharedIslandState>
```


### `<SharedIslandReducer>`

Defines the reducer function and initial value for the shared reducer state accessed in `useSharedIslandReducer()` by other islands in this JS module or partial. All islands that are are "wrapped" by `SharedIslandReducer` (i.e. are children or descendents of the children) will share a single state reference and dispatch function. Note, `SharedIslandReducer` must be rendered on the server and cannot be contained inside an island and the reducer function passed in must imported with the `?client` suffix (which will automatically prepare code-split that function for the browser to grab it).

```javascript
import reducerFuncReference from '../path/to/reducerFunc.js?client';
<SharedIslandReducer value={...} reducer={reducerFuncReference} >
  …
</SharedIslandReducer>

// reducerFunc.js
export default function reducerFunc(state, action) {
  if (action.type === 'increment') {
    state = {
      ...state,
      new: ‘state value’
    };
  }

  return state;
}
```

## @hubspot/cms-dev-server

`@hubspot/cms-dev-server` is a package that allows users to start an Express + Vite dev server enabling an auto-reloading local development workflow that is nearly identical to your deployed components. The `cms-dev-server` also enables rendering local versions of your components on live CMS pages to aid in development.

Users can start the cms-dev-server by running `hs-cms-dev-server /path/to/components-directory` in a project that has `@hubspot/cms-dev-server` installed.

For example, a CMS page with JS rendered components “https://cmssite.com/page" would be accessible by visiting one of:

- http://cmssite.com.hslocal.net:3000/page
- http://cmssite.com.localhost:3000/page

Or by visiting http://hslocal.net:3000/proxy and pasting in the page you want to proxy.

You may also start the dev server with the `--ssl` option, which enables:

- https://cmssite.com.hslocal.net:3000/page
- https://cmssite.com.localhost:3000/page

## Styling

You can use [CSS Modules](https://github.com/css-modules/css-modules) within any React components by importing a file ending in .module.css, which will return a CSS module object:

```css
/example.module.css */

.red {
  color: red;
}

/How to have global—non-namespaced—styles in CSS modules */
:global(html) {
  border: 6px solid SteelBlue;
}
```

```javascript
import classes from './example.module.css';

export default function MyComponent() {
  return <div className={classes.red}>red text</div>;
}
```

When you important a CSS modules file from inside a React component:

- A `<style>` tag will automatically be inserted into the page for you when the component is server-rendered OR when it is dynamically rendered on in the browser
- Those styles will automatically be namespaced so they don’t interfere with anything else on the page

Note, you can also import regular CSS files into your React components. But their selectors will not be automatically namespaced.

### Dynamic styles based on props

If you need to dynamically adjust styles based on props, here are some options:

- If you have some conditional style that is either on or off, then you can have a className that the React component code conditionally renders in your JSX.
- However if you have some dynamic style that is not a toggle but rather a specific color or number that you need to apply to your styles then you can:
  - Define CSS custom properties in your CSS or CSS modules code and inject new CSS custom property values via React
  - Use React to set inline styles on the specific part of the module HTML needed

Here’s a hypothetical example of all three of those techniques in action:

```css
/example2.module.css */

.fancy-module-wrapper {}

.purple-border {
  border: 2px solid rebeccapurple;
}

.second-text {
  color: var(--second-text-color, mediumvioletred);
}
```

```javascript
import styles from './example2.module.css';

export default function FancierComponent(props) {
  const { hasPurpleBorder, paddingPx, customSecondTextColor } = props;

  // Example: toggling styles via a prop
  const classes = [styles['fancy-module-wrapper']];
  if (hasPurpleBorder) {
    classes.push(styles['purple-border']);
  }

  // Example: using inline style attribute (with React's style syntax)
  const inlineStyles = { padding: paddingPx };

  // Example: setting a CSS custom property value that's picked up by other CSS
  const inlineAndCustomPropertyStyles = {
    ...inlineStyles,
    '--second-text-color': customSecondTextColor,
  };

  return (
    <div className={classes.join(' ')} style={inlineAndCustomPropertyStyles}>
      <p>First text</p>
      <p className={styles['second-text']}>Second text</p>
    </div>
  );
}
```

## Static Assets

Static asset in your modules with common extensions will resolve to public URLs automatically:

```javascript
import myImage from './myImage.png';

export default function MyComponent() {
  return <img src={myImage} />;
}
```

See [Vite’s static asset documentation](https://vitejs.dev/guide/assets.html) for more information.

## Third-party dependencies

JS modules and JS partials can depend on public third-party NPM dependencies inside and outside of Islands. Dependency code will only be bundled and sent to the client if it is referenced from an Island. You can specify a package and version in the `dependencies` field of your `package.json` within your asset package that will be used in the project build. Note that the build process runs a `production` installation of dependencies, so `devDependencies` will not be included.

If you use parts of our API from `@hubspot/cms-components` such as `Island`, you can specify a `dependencies` version to use in your build. If no [semver range](https://github.com/npm/node-semver#versions) is included in the version, a `^` range will be added to ensure future builds pick up patch releases to `@hubspot/cms-components` without breaking changes.

## Prerendering

JS modules and JS partials will be prerendered by default as part of the overall CMS page logic to prerender providing a faster load time for static content. JS partials that are passed [prerender-incompatible HubL values](https://developers.hubspot.com/docs/cms/developer-reference/cdn/prerendering?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#incompatible-hubl-variables) will not be prerendered, since the HubL referencing it will disqualify it from prerendering. See the [prerendering documentation](https://developers.hubspot.com/docs/cms/developer-reference/cdn/prerendering?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764) for more information.

## Testing

With JS building blocks it is easy to unit test your components using [Vitest](https://vitest.dev/) and [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/).

To add tests to your own project, start by adding those packages as dev dependencies, as well as `@vitejs/plugin-react` (for React support)

For Vitest to work properly with your React components add a vitest.config.js in your package root.

```javascript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
});
```

When writing a test file that uses React Testing Library to render components or referencing any browser-specific APIs, [add this to the top of the file](https://vitest.dev/guide/environment.html#test-environment):

```javascript
// @vitest-environment jsdom
```

This enables React Testing Library’s [`render`](https://testing-library.com/docs/react-testing-library/api/#render) function to work.

