# API reference

## Table of Contents

- [Project Structure](#project-structure)
- [JS Partials](#js-partials)
- [JS Modules](#js-modules)
- [Islands](#islands)
- [Getters](#getters)
- [Hooks](#hooks)
- [Components](#components)
- [cms-dev-server](#hubspotcms-dev-server)
- [Styling](#styling)
- [Static assets](#static-assets)
- [Third-party dependencies](#third-party-dependencies)
- [Prerendering](#prerendering)
- [Testing](#testing)
- [Data Fetching](#data-fetching)

## Project Structure

This is the top-level structure to be used for JS rendering projects:

```
project-folder/
│
├── js-package/
│   ├── components/
│   │   ├── partials/
│   │   └── modules/
│   ├── cms-assets.json
│   └── package.json
│
├── … optionally other project components …
│
└── hsproject.json
```

A `hsproject.json` file must be inside the root of your project folder in order for `hs project upload` to recognize your project. A `cms-assets.json` file must be inside of your JavaScript asset package subfolder so that the project build can recognize and correctly build your JS components.

This JS building blocks beta introduces the “CMS assets” project component alongside private apps, CRM extensions, and serverless functions. To learn more about HubSpot projects, you can check out the [projects beta documentation](https://developers.hubspot.com/docs/platform/build-and-deploy-using-hubspot-projects).

The examples in this repo have both a "CMS Assets" project component and a "HubL Theme" within them. This is done to illustrate one way a developer might organize code. That said a "HubL Theme" and a "CMS Asset Project Component" are two different things in HubSpot and currently there nothing that couples them. We have a `package.json`, `.eslintrc.js`, `prettierrc` at the same level as the "HubL Theme" and "CMS Assets Project Component" as a convenience. We leverage that structure to have helpful scripts in the examples' `package.json`.

## JS Partials

Similar to [global partials](https://developers.hubspot.com/docs/cms/building-blocks/global-content?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#global-partials-vs-global-modules), JavaScript partials are “slices” of your page that can be replaced with React. These can be used globally within HubL. Partials must be located in the `components/partials/` subdirectory of the JavaScript project component. For instance, if you have a file `components/partials/Header.jsx`, which default exports a React component, then you can include it in your project HubL like so:

```
{% js_partial
   path="@projects/project-folder/js-package/components/partials/Header.jsx"
   pageTitle="My page"
%}
```

Any parameters passed to `js_partial` alongside the `path` will be available within the React component as props.

## JS Modules

A JS module is just like a [traditional HubL module](https://developers.hubspot.com/docs/cms/building-blocks/modules?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764), in that they have fields, can be edited in the page editor, and can be dragged into Drag and Drop areas, but its HTML is generated by a React component instead of HubL and its fields are generated by JSX instead of JSON. JS Modules must be located in the `components/modules/` subdirectory of the JavaScript project component. JS modules are referenced in HubL like so:

```
{% module "todos"
   path="@projects/hello-world-project/cms-assets/components/modules/TodoList"
%}
```

### Directory Structure Requirements

JS Modules and JS Partials can live at either of the following paths, using the directory or file name as the module/partial name:

`/components/modules/ExampleModule/index.js`
`/components/partials/ExamplePartial/index.js`

```
js-package/
└── components/
    └── modules/
        └── ExampleModule/
            └── index.jsx
    └── partials/
        └── ExamplePartial/
          └── index.jsx
```

and/or:

`/components/modules/ExampleModule.jsx`
`/components/partials/ExamplePartial.jsx`

```
js-package/
└── components/
    └── modules/
        └── ExampleModule.jsx
    └── partials/
        └── ExamplePartial.jsx
```

Regardless of the path you chose, JS partials (i.e. either `ExamplePartial/index.jsx` or `ExamplePartial.jsx`) must export your component as a default export.


JS Modules (i.e. either `ExampleModule/index.jsx` or `ExampleModule.jsx`) must contain the following named exports:

- `Component`: A React component to be rendered. It may contain islands
- `meta`: A JavaScript object, equivalent to the ￼`meta.json`￼ [in CMS modules](https://developers.hubspot.com/docs/cms/building-blocks/modules/configuration?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#meta-json)
- `fields`: A JSX tree using components from `@hubspot/cms-components/fields` to define [module fields](https://docs.google.com/document/d/1SedUwFswfBIxRPDtjlr1LE7sqRSvIcuS9tQXp0f0lKU/edit#heading=h.m2dvp7qc12un)
Note that you may use re-exports, for example:

```
// Directory Structure
js-package/
└── components/
    └── modules/
        └── ExampleModule/
            ├── ExampleModuleFields.jsx
            ├── ExampleModuleComponent.jsx
            ├── ExampleModuleMeta.js
            └── index.js
```

```javascript
// index.js
/*
 Note: index.js re-exports ExampleModuleFields.jsx,
 ExampleModuleMeta.js, and ExampleModuleComponent.jsx as named
 exports
 */
export { default as Component } from './ExampleModuleComponent.js;
export { fields } from './ExampleModuleFields.js;
export { meta } from './ExampleModuleMeta.js;
```

### Module Fields

Fields are expressed as a JSX tree using field components from `@hubspot/cms-components/fields` . These are the same [module fields](https://developers.hubspot.com/docs/cms/building-blocks/modules?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#fields-json) that a developer has access to today. They also include TypeScript definitions, so developers can benefit from autocomplete and validation when defining fields. [Here](/field-types/modules.md) are the TypeDocs of all the exported Field Types.

### Writing Fields.jsx files

Instead of JSON, JS module fields are written using JSX. We believe the JSX field syntax is easier to read than JSON fields. It also allows you to dynamically generate fields, share field logic between modules, and create custom abstractions around field definitions. For example, here is a `FullNameField` custom field component that abstracts out a group of 2 or 3 text fields:

```javascript
import {
  ModuleField,
  TextField,
  FieldGroup,
  BooleanField
} from '@hubspot/cms-components/fields';

const FullNameField = ({ includeMiddleName = false }) => (
  <FieldGroup
    name="full_name"
    label="Full Name"
>
    <TextField
      name="given_name"
      label="Given Name"
      default="HubSpot"
      required={true}
    />
    {includeMiddleName && (
      <TextField
        name="middle_name"
        label="Middle Name"
        default=""
      />
    )}
    <TextField
      name="family_name"
      label="Family Name"
      default="Developer"
    />
  </FieldGroup>
);


export const fields = (
  <ModuleField>
    <TextField
      name="example_field"
      label="Example Text Field"
      default="Placeholder text" />

    <FieldGroup name="group_of_fields" label="Field Group">
      <BooleanField
        name="child_boolean_field"
        label="Child Boolean Field"
        default={true}
      />
      <TextField
        name="child_text_field"
        label="Child Text Field"
        default="Child Field"
      />
    </FieldGroup>


    {/Using the custom field component alongside other fields*/}
    <FullNameField includeMiddleName={false}>
  </ModuleField>
);
```

It's important to note that the root component of the `fields` export is `ModuleField`, this is required. Addtionally we are making use of `FieldGroup` which is a special component type that creates a [Field Group](https://developers.hubspot.com/docs/cms/building-blocks/module-theme-fields-overview#field-groups) that includes the nested fields.

In the `FullNameField` React component for the module fields defined above, props will have the following shape:

```javascript
{
  example_field: "Placeholder text",
  group_of_fields: {
    child_boolean_field: true,
    child_text_field: "Child Field"
  },
  full_name: {
    given_name: "HubSpot",
    family_name: "Developer",
  }
}
```

Note that the default was used to fill in the value field once it was passed. This is because module values are passed from the server, so if someone changes the value of a field in the page editor, the new value will be passed to your module. But in our current case where no page-level field value is set, the server passes the default value to your props.

#### RepeatedFieldGroup

In addition to `ModuleFields` and `FieldGroup`, another special component type from `@hubspot/cms-components/fields` is `RepeatedFieldGroup`. It creates a repeater and is used like so:

```javascript
export const fields = (
  <ModuleField>
    <RepeatedFieldGroup
        name="default_todos"
        label="Default Todos"
        occurrence={{
          min: 1,
          max: 500,
          default: 1,
        }}
        default={[
          {
            text: 'Todo Test 1a',
            completed: false
          },{
            text: 'Todo Test 2',
            completed: true
          },
        ]}
      >
      <TextField
        label="Todo title"
        name="text"
        default="Todo..."
        required
      />
      <BooleanField label="Todo Completed" name="completed" default={false} />
    </RepeatedFieldGroup>
  </ModuleField>
)

```

### Using Field Values

Field values are passed as props to the Component export of your module. For example, to use the field structure from the previous example inside of your JS module’s component you can:

```javascript
export const Component = ({ fieldValues }) => {
  return (
    <ul>
      <li>{fieldValues.example_field}</li>
      <li>{fieldValues.group_of_fields.child_text_field}</li>
    </ul>
  );
};
```

### GraphQL

Like in HubL modules, you can bind a GraphQL data query to a JS module. Adding a named `query` export to a module will provide the query result to render in the component props as `dataQueryResult`. You can import and re-export a `.graphql` query file or a JavaScript expression that evaluates to a GraphQL query (e.g. with [`gql-query-builder`](https://www.npmjs.com/package/gql-query-builder)). The result will be available via a `dataQueryResult` prop in the module component.

```javascript
// index.js

import ModuleComponent from './ModuleComponent.js';
import ModuleFields from './ModuleFields.js';
import ModuleMeta from './ModuleMeta.js';
import myQuery from './myQuery.graphql';

// This component will receive the query result via `dataQueryResult`
export const Component = ModuleComponent;

export const meta = ModuleMeta;

export const fields = ModuleFields;

export const query = myQuery;
```

And accessing the data in `ModuleComponent`:

```jsx
//ModuleComponent.jsx

export default function ModuleComponent(props) {
  return (
    <div>
    <span>
      {props.dataQueryResult.data.CRM.contact_collection.items[0].firstname}
    </span>
    <span>
      {props.dataQueryResult.data.CRM.contact_collection.items[0].lastname}
    </span>
    </div>
  )
}
```

The GraphQL HubSpot integration currently supports querying data from HubDB and Custom Objects. To explore your portal's GraphQL data schema and for help with writing queries check out our GraphiQL implementation within HubSpot at `app.hubspot.com/graphiql/[portalId]`.

Using GraphQL in this way will connect any module and subsequent down stream pages to updates to the query and upstream data. This is has implications for prerendering in that updates to data sources referenced from the query will cause the page to re-prerender.

## Islands

To use an interactive React component in your page—any component that responds to user input or has state—you need to wrap it with an `<Island>`.

- Here’s how you do that: When importing the component, add `?island` to the end of the import specifier
- Render the Island component from `@hubspot/cms-components`, and pass `InteractiveComponent` from the result of the `?island` import as the `module` prop
- Any serializable props (no functions) can be passed to `Island` and will be received by the component passed to module (`InteractiveComponent` will receive `someProp` when it renders both on the server and client)

```javascript
import { useState } from 'react';
import { Island } from '@hubspot/cms-components';
import InteractiveComponent from '../InteractiveComponent?island';

export default function MyPartial() {
  let [count, setCount] = useState(0);

  return (
    <div>
      <p>
        This content outside of `InteractiveComponent` is server-rendered only
      </p>

      {/*
        This Island wrapper will auto code-split
        InteractiveComponent for you, render it on the server,
        and set it up to hydrate in the browser.
        */}
      <Island module={InteractiveComponent} defaultCount={42} />
    </div>
  );
}
```

```javascript
import { useState } from 'react';

export default function InteractiveComponent({ defaultCount }) {
  let [count, setCount] = useState(defaultCount);

  /*
   Note, this click handler will only work if
   InteractiveComponent was called from inside an <Island>.
   Otherwise the static server HTML returned will be a button
   that does nothing when you try to click it.
   */
  return <button onClick={() => setCount(count + 1)}>Click me!</button>;
}
```

### Island props

#### `hydrateOn`

When rendering a page with Islands on the server the output includes a script to initialize Islands on the client. The default behavior of the island initialization script is to eagerly hydrate all Islands as soon as possible, i.e., on load, but there are other strategies available when hydrating components.

The available hydration types are:

- `load` (default)
- `idle`
- `visible`

These types can be set as the hydrateOn prop on the Island Component, for example:

```javascript
<Island module={InteractiveComponent} hydrateOn=”visible” />
```

For islands with the `idle` hydration type we use [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), allowing the hydration to be deferred. This is good for lower priority components, allowing client resources to be used first on higher priority.

For Islands with the `visible` hydration type we don’t hydrate until the element is visible on screen by using the [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). This mode is good for components that aren't visible to the user immediately, e.g., if they are further down a long page.

Hydrating means downloading and initializing your Island component code, so using these different hydration types strategically to defer some of that work can help boost initial page load performance!

#### `clientOnly`

`boolean`

This is set to `false` by default, but when set to `true` then the Island won’t be rendered on the server. This can be useful for components that rely on logic/libraries that can only run in the browser.

## Getters

### `getHubID`

`( ) => number`

Returns the the current account ID (“Hub ID” or “portal ID”) for the page being rendered

### `getIsDeployed`

`( ) => boolean`

Returns `true` for components rendered live for a deployed project and `false` when rendering in the dev server.

## Hooks

We provide a number of React hooks from the `@hubspot/cms-components` package to help write components that run on both the server and the browser.

### `useAfterIslandHydration`

`( ) => boolean`

Will return `true` only after hydration is completed. More specifically it will:

- Return `true` during the initial render on the server.
- Return `true` during the first render that happens inside the browser.
- Return `false` during any subsequent renders that happen after the component has been “mounted” in the browser.

This hook is useful because React requires server-rendered HTML to match the initial client render. See the [Server/Client Rendering section](appendix.md#server-sideclient-side-rendering) in the appendix for more information.

### `￼useIsServerRender`

`( ) => boolean`

Returns `true` while the component is being rendered on the server and `false` in the browser. Note, in most cases it is better to use `useAfterIslandHydration()`, since it makes it easier for your code to “do the right thing” for hydration.

### `usePageUrl`

`( ) => URL`

Returns the current page [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL). Works on server and is reactive to changes to the URL on client. This can be useful when components need to react to URL changes, such as query params, while also supporting server rendering. To programmatically trigger non-navigation URL changes, use `pushHistoryState()` which is identical to `window.history.pushState()` but integrates with `usePageUrl()` to ensure it receives change events.

### `useInlineHeadAsset`

`(renderFunc: () => JSX.Element) => void`

Provides an API to pass HTML to render in the `<head>`. This is most useful for collecting CSS from CSS-in-JS libraries and including the emitted CSS in the initial page response. See [Styling](#styling) for more details.

### `useSharedIslandState`

```javascript
const [sharedState, updateSharedState, sharedStateID] = useSharedIslandState();
```

Returns an object of state shared multiple islands and updater function. It works similarly to `useState`, but updating the state via `updateSharedState(newValue)` will "reach across" and update all of the other islands that also use `useSharedIslandState()`. Works in coordination with the `SharedIslandState` component.

### `useSharedIslandReducer`

```javascript
const [sharedState, dispatch] = useSharedIslandReducer();
```

Returns an object of state shared multiple islands and a dispatch function. It works similarly to `useReducer`, but actions dispatched will "reach across" and update all of the other islands that also use `useSharedIslandReducer()`. Works in coordination with the `SharedIslandReducer` component.

## Components

### `<SharedIslandState>`

Defines the initial value for the shared state accessed in `useSharedIslandState()` by other islands in this JS module or partial. All islands that are are "wrapped" by `SharedIslandState` (i.e. are children or descendents of the children) will share a single state reference. Note, `SharedIslandState` must be rendered on the server and cannot be contained inside an island.

```javascript
<SharedIslandState value={...}>
  …
</SharedIslandState>
```


### `<SharedIslandReducer>`

Defines the reducer function and initial value for the shared reducer state accessed in `useSharedIslandReducer()` by other islands in this JS module or partial. All islands that are are "wrapped" by `SharedIslandReducer` (i.e. are children or descendents of the children) will share a single state reference and dispatch function. Note, `SharedIslandReducer` must be rendered on the server and cannot be contained inside an island and the reducer function passed in must imported with the `?client` suffix (which will automatically prepare code-split that function for the browser to grab it).

```javascript
import reducerFuncReference from '../path/to/reducerFunc.js?client';
<SharedIslandReducer value={...} reducer={reducerFuncReference} >
  …
</SharedIslandReducer>

// reducerFunc.js
export default function reducerFunc(state, action) {
  if (action.type === 'increment') {
    state = {
      ...state,
      new: ‘state value’
    };
  }

  return state;
}
```

## @hubspot/cms-dev-server

`@hubspot/cms-dev-server` is a package that allows users to start an Express + Vite dev server enabling an auto-reloading local development workflow that is nearly identical to your deployed components. The `cms-dev-server` also enables rendering local versions of your components on live CMS pages to aid in development.

Users can start the cms-dev-server by running `hs-cms-dev-server /path/to/components-directory` in a project that has `@hubspot/cms-dev-server` installed.

For example, a CMS page with JS rendered components “https://cmssite.com/page" would be accessible by visiting one of:

- http://cmssite.com.hslocal.net:3000/page
- http://cmssite.com.localhost:3000/page

Or by visiting http://hslocal.net:3000/proxy and pasting in the page you want to proxy.

Similar to how previewing a page from the page editor works, you can force the page to render with the context of a contact by passing an `email` parameter. For example `http://cmssite.com.hslocal.net:3000/page?email=bh@hubspot.com` will cause the contact object to be populated based on the email parameter value.

You may also start the dev server with the `--ssl` option, which enables:

- https://cmssite.com.hslocal.net:3000/page
- https://cmssite.com.localhost:3000/page

## Styling

Refer to the [styling example project](/styling/styling-project/styling-app) for working examples of supported methods of styling your components, including a number of major styling libraries.

### Tailwind

You can configure [Tailwind](https://tailwindcss.com/) for your components by doing the following:

- Add a dependency to `tailwindcss` to your `package.json`
- Add a PostCSS configuration file to your project subcomponent including tailwind as a plugin
- Refer to a Tailwind config in that plugin with any Tailwind-specific configuration
- Import a CSS file in your top level component with the base Tailwind layer directives

See the `TailwindPartial` component and the relevant configuration in the example for more detail.

### styled-components

You can use [`styled-components`](https://styled-components.com) in your project by doing the following:

- Add a `dependency` on `styled-components` to your `package.json`
- Create a registry component using the styled-components [server side rendering](https://styled-components.com/docs/advanced#server-side-rendering) API along with [`useInlineHeadAsset()`](#useInlineHeadAsset) and wrap the components you intend to style in it. The example includes a `StyledComponentsRegistry.jsx` you can use.
- For each Island usage, you must wrap each subtree in a registry to capture styles when rendering on the server. To make this easier you may use the `Wrapper` prop on the `Island` component to wrap the contents without needing to edit the island components themselves. Note that when using the `Wrapper` prop **you must import the component passed with a `?client` suffix** to make sure it can be bundled for the client. This prop also lets you configure this once by replacing all instances of `<Island />` with a `<StyledIsland />` that looks something like:

```javascript
import { Island } from '@hubspot/cms-components';
import StyledComponentsRegistry from './StyledComponentsRegistry?client';

export default function StyledIsland(props) {
  return <Island {...props} Wrapper={StyledComponentsRegistry} />
}
```

- You can now `import styled from 'styled-components';` and use it to style your components.

### styled-jsx

Steps to use `styled-jsx` are:

- Add a dependency on `styled-jsx` to your `package.json`
- Create a registry component using the [server side rendering](https://github.com/vercel/styled-jsx#server-side-rendering) API and [`useInlineHeadAsset()`](#useInlineHeadAsset). The example includes a `StyledJSXRegistry.jsx` to refer to or use.
- The registry component for `styled-jsx` must also be wrapped on any `Island` usage to prevent hydration mismatches or missing styles on initial load. Note that `styled-jsx`'s implementation depends on `useId()` hooks in a way that can cause mismatches if not properly configured. See the `StyledJSXIsland.jsx` implementation from the example for an easier pattern of replacing all direct `<Island />` usage.
- You can now use `styled-jsx` to style your components, including ``<style jsx>{` /* CSS here */ `}</style>`` patterns.

### CSS Modules

You can use [CSS Modules](https://github.com/css-modules/css-modules) within any React components by importing a file ending in .module.css, which will return a CSS module object:

```css
/example.module.css */

.red {
  color: red;
}

/How to have global—non-namespaced—styles in CSS modules */
:global(html) {
  border: 6px solid SteelBlue;
}
```

```javascript
import classes from './example.module.css';

export default function MyComponent() {
  return <div className={classes.red}>red text</div>;
}
```

When you important a CSS modules file from inside a React component:

- A `<style>` tag will automatically be inserted into the page for you when the component is server-rendered OR when it is dynamically rendered on in the browser
- Those styles will automatically be namespaced so they don’t interfere with anything else on the page

Note, you can also import regular CSS files into your React components. But their selectors will not be automatically namespaced.

#### Dynamic styles based on props

If you need to dynamically adjust styles based on props, here are some options:

- If you have some conditional style that is either on or off, then you can have a className that the React component code conditionally renders in your JSX.
- However if you have some dynamic style that is not a toggle but rather a specific color or number that you need to apply to your styles then you can:
  - Define CSS custom properties in your CSS or CSS modules code and inject new CSS custom property values via React
  - Use React to set inline styles on the specific part of the module HTML needed

Here’s a hypothetical example of all three of those techniques in action:

```css
/example2.module.css */

.fancy-module-wrapper {}

.purple-border {
  border: 2px solid rebeccapurple;
}

.second-text {
  color: var(--second-text-color, mediumvioletred);
}
```

```javascript
import styles from './example2.module.css';

export default function FancierComponent(props) {
  const { hasPurpleBorder, paddingPx, customSecondTextColor } = props;

  // Example: toggling styles via a prop
  const classes = [styles['fancy-module-wrapper']];
  if (hasPurpleBorder) {
    classes.push(styles['purple-border']);
  }

  // Example: using inline style attribute (with React's style syntax)
  const inlineStyles = { padding: paddingPx };

  // Example: setting a CSS custom property value that's picked up by other CSS
  const inlineAndCustomPropertyStyles = {
    ...inlineStyles,
    '--second-text-color': customSecondTextColor,
  };

  return (
    <div className={classes.join(' ')} style={inlineAndCustomPropertyStyles}>
      <p>First text</p>
      <p className={styles['second-text']}>Second text</p>
    </div>
  );
}
```

### Other CSS-in-JS libraries

Other CSS-in-JS libraries that provide a server side rendering API and don't depend on a Babel plugin can be used within HubSpot projects. The same registry pattern described above can be generalized for other libraries to emit CSS to include as part of the server render. The registry will need to be included as a `Wrapper` on any `<Island />` usage as well if there are styles within the island.

## Static Assets

Static asset in your modules with common extensions will resolve to public URLs automatically:

```javascript
import myImage from './myImage.png';

export default function MyComponent() {
  return <img src={myImage} />;
}
```

See [Vite’s static asset documentation](https://vitejs.dev/guide/assets.html) for more information.

## Third-party dependencies

JS modules and JS partials can depend on public third-party NPM dependencies inside and outside of Islands. Dependency code will only be bundled and sent to the client if it is referenced from an Island. You can specify a package and version in the `dependencies` field of your `package.json` within your asset package that will be used in the project build. Note that the build process runs a `production` installation of dependencies, so `devDependencies` will not be included.

If you use parts of our API from `@hubspot/cms-components` such as `Island`, you can specify a `dependencies` version to use in your build. If no [semver range](https://github.com/npm/node-semver#versions) is included in the version, a `^` range will be added to ensure future builds pick up patch releases to `@hubspot/cms-components` without breaking changes.

## Prerendering

JS modules and JS partials will be prerendered by default as part of the overall CMS page logic to prerender providing a faster load time for static content. JS partials that are passed [prerender-incompatible HubL values](https://developers.hubspot.com/docs/cms/developer-reference/cdn/prerendering?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764#incompatible-hubl-variables) will not be prerendered, since the HubL referencing it will disqualify it from prerendering. See the [prerendering documentation](https://developers.hubspot.com/docs/cms/developer-reference/cdn/prerendering?__hstc=75491725.e2098b212e147a7b9be6fd756c0c6815.1649440584659.1667397195793.1667489478959.105&__hssc=75491725.4.1667489478959&__hsfp=1149209764) for more information.

## Testing

With JS building blocks it is easy to unit test your components using [Vitest](https://vitest.dev/) and [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/).

To add tests to your own project, start by adding those packages as dev dependencies, as well as `@vitejs/plugin-react` (for React support)

For Vitest to work properly with your React components add a vitest.config.js in your package root.

```javascript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
});
```

When writing a test file that uses React Testing Library to render components or referencing any browser-specific APIs, [add this to the top of the file](https://vitest.dev/guide/environment.html#test-environment):

```javascript
// @vitest-environment jsdom
```

This enables React Testing Library’s [`render`](https://testing-library.com/docs/react-testing-library/api/#render) function to work.

## Data Fetching

Getting content and data into your JS Modules or JS Partials can take many forms as the sources are varied and nuanced.

### HubSpot Content - Server Side

In an ideal world the HubSpot GraphQL integration would be the go to for getting all of your HubSpot content into the JS Building Blocks. Currently however, GraphQL only supports querying HubDB and Custom Objects - refer to the [GraphQL](#graphql) documentation above. There are some key advantages to using the GraphQL integration with JS Building Blocks

- Co-located Query and Component
- One single Query for needed associations e.g. contact->company
- Tight coupling with prerendering rules e.g. updates to the query or relevant data will cause a re-prerender of any downstream connected page.

That said there are other kinds of HubSpot data you might want access to within your JS Building Blocks. The current way to accomplish this by passing that information from a HubL template to a JS Building Blocks via the `js_partial` and `module` HubL tags. For example:

```handlebars
{% module "contact_profile"
    path="@projects/contact-profile-project/contact-profile-app/components/modules/ContactProfile",
    firstName="{{contact.firstname}}",
    lastName="{{contact.lastname}}",
    email="{{contact.email}}" %}
```

And then on the React side:

```jsx
// contact-profile-project/contact-profile-app/components/modules/ContactProfile/index.jsx
export const Component = (props) => {
  return (
    <div>
      <span>{props.hublParameters.firstName}</span>
      <span>{props.hublParameters.lastName}</span>
      <span>{props.hublParameters.email}</span>
    </div>
  )
}
```

Whether you are passing data via the HubL tags or querying via GraphQL these solutions account only for reading data, not for creating or updating data in your HubSpot portal. The JS Building Blocks today don't offer any new avenues for manipulating your HubSpot Data.

### HubSpot Content - Client Side

As is the case today, you can make use of public APIs to fetch your HubSpot data from the browser. While the JS Building Blocks don't offer any HubSpot specific tools for data fetching on the client, we think the introduction of [Islands](#islands) will allow for more optimized and ergonomic client side data fetching. Relative to updating your HubSpot data - the recommended path would still be to implement a [Serverless Function](https://developers.hubspot.com/docs/cms/data/serverless-functions) that is responsible for securely making calls to HubSpot APIs. The serverless function would then expose and endpoint that a developer could makes requests to from the client.

### External Content - Server Side

While there is no pathway for this currently, our goal is to open up a pathway for developers to do async tasks dynamically at render time. This would allow for making server-side API requests to arbitrary 3rd party services. We do not currently have a timeline for when this will be available. The advantage to server side data fetching is that a developer can make requests that require secrets or tokens safely, in addition to the performance benefit of server rendered dynamic content.

### External Content - Client Side

Similar to the client side HubSpot Content scenario there is no real "change" in in terms of what is possible for fetching data on the client.
